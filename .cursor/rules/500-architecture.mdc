# 아키텍처 및 프로젝트 구조 규칙

## 프로젝트 구조 원칙

### 폴더 구조
```
app/                    # Next.js App Router
  (auth)/              # 인증 관련 라우트 그룹
  (onboarding)/        # 온보딩 라우트 그룹
  (dashboard)/         # 메인 앱 라우트 그룹
components/
  ui/                  # shadcn/ui 기반 공통 컴포넌트
  domain/              # 비즈니스 로직 컴포넌트
  providers/           # Context Providers
lib/
  supabase/            # Supabase 클라이언트 및 쿼리
  ai/                  # AI 관련 로직
  utils/               # 유틸리티 함수
hooks/                 # 커스텀 훅
types/                 # TypeScript 타입 정의
docs/                  # 프로젝트 문서
```

## 컴포넌트 아키텍처

### 컴포넌트 분리 원칙

**`components/ui/`** - 공통 UI 컴포넌트:
- 목적: 재사용 가능한 순수 UI 컴포넌트
- 특징: 비즈니스 로직 없음, Props 기반 동작
- 예시: `Button`, `Card`, `Input`, `Select`

**`components/domain/`** - 도메인별 비즈니스 컴포넌트:
- 목적: 특정 기능 영역의 비즈니스 로직 포함
- 구조:
  - `auth/`: 인증 관련
  - `onboarding/`: 온보딩 폼
  - `feed/`: 매칭 피드
  - `profile/`: 프로필 관련
  - `layout/`: 레이아웃 컴포넌트
- 예시: `GoogleLoginButton`, `CandidateCard`, `FilterBar`

### 컴포넌트 설계 원칙

1. **단일 책임 원칙**: 각 컴포넌트는 하나의 명확한 책임만 가짐
2. **재사용성**: 공통 로직은 컴포넌트로 추출
3. **조합**: 작은 컴포넌트를 조합하여 큰 컴포넌트 구성
4. **Props 인터페이스**: 명확한 타입 정의

## 데이터 레이어 아키텍처

### 쿼리 함수 분리 (`lib/supabase/queries/`)

**원칙**:
- 도메인별 파일 분리 (`profiles.ts`, `matching-posts.ts`)
- 각 함수는 단일 책임
- 에러 핸들링 포함
- 타입 안정성 보장

**구조**:
```typescript
// lib/supabase/queries/profiles.ts
export async function getProfile(userId: string): Promise<Profile> {
  // ...
}

export async function createProfile(data: ProfileInput): Promise<Profile> {
  // ...
}

export async function updateProfile(
  userId: string,
  data: Partial<ProfileInput>
): Promise<Profile> {
  // ...
}
```

### 커스텀 훅 (`hooks/`)

**목적**: 상태 관리 및 데이터 페칭 로직 재사용

**구조**:
```typescript
// hooks/use-profile.ts
export function useProfile(userId: string) {
  const [profile, setProfile] = useState<Profile | null>(null);
  const [loading, setLoading] = useState(true);
  // ...
  return { profile, loading, error };
}
```

**원칙**:
- 하나의 훅은 하나의 책임만 담당
- 서버 상태는 React Query 또는 SWR 활용 (선택사항)
- 클라이언트 컴포넌트에서만 사용

## 라우팅 아키텍처

### Route Groups 활용

**`(auth)/`**: 인증 관련 라우트
- 공통 레이아웃 없음
- 예: `/login`

**`(onboarding)/`**: 온보딩 라우트
- 온보딩 전용 레이아웃
- 예: `/onboarding/step-1`, `/onboarding/step-2`

**`(dashboard)/`**: 메인 앱 라우트
- 탭 네비게이션 포함 레이아웃
- 예: `/feed`, `/profile`

### 동적 라우팅
- `feed/[id]/page.tsx`: 프로필 상세 페이지
- 타입 안정성: `params`는 `Promise`로 래핑 (Next.js 15)

### API Routes
- `api/auth/callback/`: OAuth 콜백 처리
- `api/matching/generate-summary/`: AI 매칭 요약 생성
- `api/matching/reveal-contact/`: 연락처 공개 (조회권 차감)
- `api/profile/`: 프로필 CRUD

## 상태 관리 아키텍처

### 서버 상태 우선
- 기본적으로 서버 컴포넌트에서 데이터 페칭
- 클라이언트 상태는 최소화

### 클라이언트 상태 관리
- **로컬 상태**: `useState` (컴포넌트 내부)
- **전역 상태**: Context API (`AuthProvider`)
- **URL 상태**: `nuqs` (필터, 탭 상태)

### 폼 상태 관리
- React Hook Form 활용 (선택사항)
- 서버 액션 또는 API Route로 제출

## 타입 시스템 아키텍처

### 타입 정의 구조 (`types/`)

**`database.ts`**: Supabase 자동 생성 타입
```typescript
export type Database = {
  // Supabase CLI로 자동 생성
};
```

**`profile.ts`**: 프로필 관련 타입
```typescript
export interface Profile {
  id: string;
  name: string;
  // ...
}
```

**`matching.ts`**: 매칭 관련 타입
```typescript
export interface MatchingPost {
  id: string;
  user_id: string;
  // ...
}
```

**`api.ts`**: API 응답 타입
```typescript
export type APIResponse<T> = {
  data?: T;
  error?: string;
};
```

**`index.ts`**: 타입 재export
```typescript
export * from "./database";
export * from "./profile";
// ...
```

## 보안 아키텍처

### 인증 흐름
1. Google OAuth → Supabase Auth
2. 세션 토큰 관리 (Supabase 자동)
3. 서버 사이드 인증 검증

### 데이터 접근 제어
- RLS 정책으로 데이터 접근 제어
- 소속관 기반 데이터 격리 필수
- 서버 사이드에서만 데이터 수정

### 개인정보 보호
- 조회권 시스템 (Phase 2)
- 마스킹 처리
- 로그 기록

## 확장성 고려사항

### Phase 1 → Phase 2 전환
- Phase 2 기능은 기존 구조에 자연스럽게 통합
- 기존 코드 수정 최소화
- 새로운 테이블 및 쿼리 함수 추가

### 코드 중복 최소화
- 공통 로직은 유틸리티 함수로 추출
- 컴포넌트 재사용 최대화
- 타입 정의 중앙화

### 성능 최적화
- 서버 컴포넌트 우선 사용
- 이미지 최적화
- 코드 스플리팅
- 캐싱 전략

## 아키텍처 결정 기록 (ADR)

### 1. Server Components 우선
**결정**: 기본적으로 Server Component 사용
**이유**: 성능 최적화, 번들 크기 감소, SEO 향상
**대안**: 모든 컴포넌트를 Client Component로 구성

### 2. Route Groups 사용
**결정**: `(auth)`, `(onboarding)`, `(dashboard)` 그룹화
**이유**: 레이아웃 분리, 코드 조직화
**대안**: 플랫한 라우트 구조

### 3. 쿼리 함수 분리
**결정**: `lib/supabase/queries/`에 도메인별 분리
**이유**: 재사용성, 테스트 용이성, 유지보수성
**대안**: 컴포넌트 내부에 직접 쿼리 작성

### 4. 타입 중앙화
**결정**: `types/` 디렉토리에 모든 타입 정의
**이유**: 타입 일관성, 재사용성
**대안**: 각 파일에 타입 정의

## 구현 체크리스트

### 새 기능 추가 시
- [ ] 적절한 디렉토리에 파일 생성
- [ ] 타입 정의 추가 (`types/`)
- [ ] 쿼리 함수 분리 (`lib/supabase/queries/`)
- [ ] 에러 핸들링 포함
- [ ] 로딩 상태 처리
- [ ] RLS 정책 확인
- [ ] 접근성 고려

### 컴포넌트 생성 시
- [ ] Server Component 우선 고려
- [ ] Props 인터페이스 명확히 정의
- [ ] 재사용 가능한지 검토
- [ ] 적절한 디렉토리에 배치 (`ui/` vs `domain/`)

### API Route 생성 시
- [ ] 인증 검증 포함
- [ ] 에러 핸들링 포함
- [ ] 타입 안정성 보장
- [ ] RLS 정책 준수
